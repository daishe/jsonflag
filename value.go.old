package jsonflag

import (
	"encoding/json"
	"reflect"
	"strconv"
	"strings"
)

type value interface {
	Path() []reflect.StructField
	Type() string
	Get() any
	String() string
	Set(string) error
	SetEncode(func(any) ([]byte, error))
	SetDecode(func([]byte, any) error)
	IsBoolValue() bool
}

type valueBase struct {
	base          reflect.Value
	fieldsIndexes []int
	fields        []reflect.StructField
	encode        func(any) ([]byte, error)
	decode        func([]byte, any) error
}

func (b *valueBase) Path() []reflect.StructField {
	return b.fields
}

func (b *valueBase) Get() any {
	return b.get().Interface()
}

func (b *valueBase) Type() string {
	t := elemIfPtrType(b.typ())
	if t.Kind() == reflect.Slice {
		if n := typeName(elemIfPtrType(t.Elem())); n != "" {
			return n + " (JSON list)"
		}
	}
	return typeName(t)
}

func (b *valueBase) SetEncode(fn func(any) ([]byte, error)) {
	b.encode = fn
}

func (b *valueBase) SetDecode(fn func([]byte, any) error) {
	b.decode = fn
}

func (b *valueBase) IsBoolValue() bool {
	return false
}

func (b *valueBase) typ() reflect.Type {
	if len(b.fields) == 0 {
		return b.base.Type()
	}
	return b.fields[len(b.fields)-1].Type
}

func (b *valueBase) get() reflect.Value {
	return fieldByIndex(b.base, b.fieldsIndexes)
}

func fieldByIndex(v reflect.Value, index []int) reflect.Value {
	if len(index) == 0 {
		if v.Kind() == reflect.Pointer && v.IsNil() {
			v.Set(reflect.New(v.Type().Elem()))
		}
		return v
	}
	if (v.Kind() != reflect.Pointer || v.Type().Elem().Kind() != reflect.Struct) && v.Kind() != reflect.Struct {
		panic("jsonflag: expected a struct or a pointer to struct, got " + v.Kind().String())
	}
	for _, x := range index {
		if v.Kind() == reflect.Pointer {
			if v.IsNil() {
				v.Set(reflect.New(v.Type().Elem()))
			}
			v = v.Elem()
		}
		v = v.Field(x)
	}
	if v.Kind() == reflect.Pointer && v.IsNil() {
		v.Set(reflect.New(v.Type().Elem()))
	}
	return v
}

func elemIfPtr(v reflect.Value) reflect.Value {
	if v.Kind() != reflect.Pointer {
		return v
	}
	if v.IsNil() {
		return reflect.Zero(v.Type().Elem())
	}
	return v.Elem()
}

func elemIfPtrType(t reflect.Type) reflect.Type {
	if t.Kind() != reflect.Pointer {
		return t
	}
	return t.Elem()
}

func valueSet(dst, src reflect.Value) {
	if dst.Kind() == reflect.Pointer && !dst.CanSet() {
		dst = dst.Elem()
	}
	if dst.Kind() == reflect.Pointer && src.Kind() != reflect.Pointer {
		src = src.Addr()
	} else if dst.Kind() != reflect.Pointer && src.Kind() == reflect.Pointer {
		src = src.Elem()
	}
	dst.Set(src)
}

func valueAppend(slc, v reflect.Value) reflect.Value {
	if slc.Elem().Kind() == reflect.Pointer && v.Kind() != reflect.Pointer {
		v = v.Addr()
	} else if slc.Elem().Kind() != reflect.Pointer && v.Kind() == reflect.Pointer {
		v = v.Elem()
	}
	return reflect.Append(slc, v)
}

func typeName(t reflect.Type) string {
	switch t.Kind() { //nolint:exhaustive // cases for only supported types
	case reflect.Bool:
		return "bool"
	case reflect.Int:
		return "int"
	case reflect.Int8:
		return "int8"
	case reflect.Int16:
		return "int16"
	case reflect.Int32:
		return "int32"
	case reflect.Int64:
		return "int64"
	case reflect.Uint:
		return "uint"
	case reflect.Uint8:
		return "uint8"
	case reflect.Uint16:
		return "uint16"
	case reflect.Uint32:
		return "uint32"
	case reflect.Uint64:
		return "uint64"
	case reflect.Uintptr:
		return "uintptr"
	case reflect.Float32:
		return "float32"
	case reflect.Float64:
		return "float64"
	case reflect.Complex64:
		return "complex64"
	case reflect.Complex128:
		return "complex128"
	case reflect.String:
		return "string"
	case reflect.Slice:
		return "JSON list"
	case reflect.Map:
		return "JSON object"
	case reflect.Struct:
		return "JSON object"
	}
	return ""
}

type boolValue struct {
	valueBase
}

func newBoolValue(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *boolValue {
	return &boolValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
	}
}

func (f *boolValue) IsBoolValue() bool {
	return true
}

func (f *boolValue) String() string {
	v := elemIfPtr(f.get()).Bool()
	if !v {
		return ""
	}
	return strconv.FormatBool(v)
}

func (f *boolValue) Set(val string) error {
	v, err := strconv.ParseBool(val)
	if err != nil {
		return err
	}
	valueSet(f.get(), reflect.ValueOf(v))
	return nil
}

type intValue struct {
	valueBase
	bitSize int
}

func newIntValue(bitSize int, base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *intValue {
	return &intValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
		bitSize: bitSize,
	}
}

func (f *intValue) String() string {
	v := elemIfPtr(f.get()).Int()
	if v == 0 {
		return ""
	}
	return strconv.FormatInt(v, 10)
}

func (f *intValue) Set(val string) error {
	v, err := strconv.ParseInt(val, 0, f.bitSize)
	if err != nil {
		return err
	}
	valueSet(f.get(), reflect.ValueOf(v))
	return nil
}

type uintValue struct {
	valueBase
	bitSize int
}

func newUintValue(bitSize int, base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *uintValue {
	return &uintValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
		bitSize: bitSize,
	}
}

func (f *uintValue) String() string {
	v := elemIfPtr(f.get()).Uint()
	if v == 0 {
		return ""
	}
	return strconv.FormatUint(v, 10)
}

func (f *uintValue) Set(val string) error {
	v, err := strconv.ParseUint(val, 0, f.bitSize)
	if err != nil {
		return err
	}
	valueSet(f.get(), reflect.ValueOf(v))
	return nil
}

type floatValue struct {
	valueBase
	bitSize int
}

func newFloatValue(bitSize int, base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *floatValue {
	return &floatValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
		bitSize: bitSize,
	}
}

func (f *floatValue) String() string {
	v := elemIfPtr(f.get()).Float()
	if v == 0 {
		return ""
	}
	return strconv.FormatFloat(v, 'g', -1, f.bitSize)
}

func (f *floatValue) Set(val string) error {
	v, err := strconv.ParseFloat(val, f.bitSize)
	if err != nil {
		return err
	}
	valueSet(f.get(), reflect.ValueOf(v))
	return nil
}

type complexValue struct {
	valueBase
	bitSize int
}

func newComplexValue(bitSize int, base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *complexValue {
	return &complexValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
		bitSize: bitSize,
	}
}

func (f *complexValue) String() string {
	v := elemIfPtr(f.get()).Complex()
	if v == 0 {
		return ""
	}
	return strconv.FormatComplex(v, 'g', -1, f.bitSize)
}

func (f *complexValue) Set(val string) error {
	v, err := strconv.ParseComplex(val, f.bitSize)
	if err != nil {
		return err
	}
	valueSet(f.get(), reflect.ValueOf(v))
	return nil
}

type stringValue struct {
	valueBase
}

func newStringValue(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *stringValue {
	return &stringValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
	}
}

func (f *stringValue) String() string {
	return elemIfPtr(f.get()).String()
}

func (f *stringValue) Set(val string) error {
	valueSet(f.get(), reflect.ValueOf(val))
	return nil
}

type mapValue struct {
	valueBase
}

func newMapValue(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *mapValue {
	return &mapValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
	}
}

func (f *mapValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *mapValue) Set(val string) error {
	t := elemIfPtrType(f.typ())
	v := reflect.MakeMap(t).Addr()
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return err
	}
	valueSet(f.get(), v)
	return nil
}

type structValue struct {
	valueBase
}

func newStructValue(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *structValue {
	return &structValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
	}
}

func (f *structValue) String() string {
	b, err := json.Marshal(f.get().Interface())
	if err != nil {
		return ""
	}
	str := string(b)
	if str == "{}" {
		return ""
	}
	return str
}

func (f *structValue) Set(val string) error {
	t := elemIfPtrType(f.typ())
	v := reflect.New(t)
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return err
	}
	valueSet(f.get(), v)
	return nil
}

type boolSliceValue struct {
	valueBase
}

func newBoolSliceValue(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *boolSliceValue {
	return &boolSliceValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
	}
}

func (f *boolSliceValue) IsBoolValue() bool {
	return true
}

func (f *boolSliceValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *boolSliceValue) Set(val string) error {
	v, err := strconv.ParseBool(val)
	if err != nil {
		return err
	}
	x := f.get()
	valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
	return nil
}

type intSliceValue struct {
	valueBase
	bitSize int
}

func newIntSliceValue(bitSize int, base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *intSliceValue {
	return &intSliceValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
		bitSize: bitSize,
	}
}

func (f *intSliceValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *intSliceValue) Set(val string) error {
	v, err := strconv.ParseInt(val, 0, f.bitSize)
	if err != nil {
		return err
	}
	x := f.get()
	valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
	return nil
}

type uintSliceValue struct {
	valueBase
	bitSize int
}

func newUintSliceValue(bitSize int, base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *uintSliceValue {
	return &uintSliceValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
		bitSize: bitSize,
	}
}

func (f *uintSliceValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *uintSliceValue) Set(val string) error {
	v, err := strconv.ParseUint(val, 0, f.bitSize)
	if err != nil {
		return err
	}
	x := f.get()
	valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
	return nil
}

type floatSliceValue struct {
	valueBase
	bitSize int
}

func newFloatSliceValue(bitSize int, base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *floatSliceValue {
	return &floatSliceValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
		bitSize: bitSize,
	}
}

func (f *floatSliceValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *floatSliceValue) Set(val string) error {
	v, err := strconv.ParseFloat(val, f.bitSize)
	if err != nil {
		return err
	}
	x := f.get()
	valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
	return nil
}

type complexSliceValue struct {
	valueBase
	bitSize int
}

func newComplexSliceValue(bitSize int, base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *complexSliceValue {
	return &complexSliceValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
		bitSize: bitSize,
	}
}

func (f *complexSliceValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	li := make([]string, 0, v.Len())
	for _, x := range v.Seq2() {
		li = append(li, `"`+strconv.FormatComplex(elemIfPtr(x).Complex(), 'g', -1, f.bitSize)+`"`)
	}
	return "[" + strings.Join(li, ",") + "]"
}

func (f *complexSliceValue) Set(val string) error {
	v, err := strconv.ParseComplex(val, f.bitSize)
	if err != nil {
		return err
	}
	x := f.get()
	valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
	return nil
}

type stringSliceValue struct {
	valueBase
}

func newStringSliceValue(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *stringSliceValue {
	return &stringSliceValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
	}
}

func (f *stringSliceValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *stringSliceValue) Set(val string) error {
	x := f.get()
	valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(val)))
	return nil
}

type sliceSliceValue struct {
	valueBase
}

func newSliceSliceValue(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *sliceSliceValue {
	return &sliceSliceValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
	}
}

func (f *sliceSliceValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *sliceSliceValue) Set(val string) error {
	sliceType := elemIfPtrType(f.typ())
	t := elemIfPtrType(sliceType.Elem()) // slice element type
	v := reflect.MakeSlice(t, 0, 0).Addr()
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return err
	}
	x := f.get()
	valueSet(x, valueAppend(elemIfPtr(x), v))
	return nil
}

type mapSliceValue struct {
	valueBase
}

func newMapSliceValue(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *mapSliceValue {
	return &mapSliceValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
	}
}

func (f *mapSliceValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *mapSliceValue) Set(val string) error {
	sliceType := elemIfPtrType(f.typ())
	t := elemIfPtrType(sliceType.Elem()) // slice element type
	v := reflect.MakeMap(t).Addr()
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return err
	}
	x := f.get()
	valueSet(x, valueAppend(elemIfPtr(x), v))
	return nil
}

type structSliceValue struct {
	valueBase
}

func newStructSliceValue(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *structSliceValue {
	return &structSliceValue{
		valueBase: valueBase{
			base:          base,
			fieldsIndexes: fieldsIndexes,
			fields:        fields,
		},
	}
}

func (f *structSliceValue) String() string {
	v := elemIfPtr(f.get())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *structSliceValue) Set(val string) error {
	sliceType := elemIfPtrType(f.typ())
	t := elemIfPtrType(sliceType.Elem()) // slice element type
	v := reflect.New(t)
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return err
	}
	x := f.get()
	valueSet(x, valueAppend(elemIfPtr(x), v))
	return nil
}
