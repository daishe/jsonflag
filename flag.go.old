package jsonflag

import (
	"encoding/json"
	"fmt"
	"reflect"
	"slices"
	"strconv"
	"strings"
)

// Flag implements a single flag for a certain key or object.
type Flag interface {
	Path() []reflect.StructField
	Type() reflect.Type
	Default() string
	Apply(Operations, string) (Operations, error)
}

// New returns new flag for the provided value. It returns nil it the value cannot be used as flag value.
func New(def any) Flag {
	if def == nil {
		return nil
	}
	base := reflect.ValueOf(def)
	if !base.CanSet() && (base.Kind() != reflect.Pointer || base.IsNil()) {
		return nil
	}
	return newFlag(base, nil, nil)
}

// FilterFunc is a function that can decide if a flag should be included in recursive results as well as if flags finding should descend into the sub-flags.
type FilterFunc func(Flag) FilterResult

// FilterResult is a bit field holding filtering decision.
type FilterResult uint32

const (
	IncludeAndDescend FilterResult = 0b00 // indicates that the given flag should be included and flags finding should descend into sub-flags
	IncludeNoDescend  FilterResult = 0b01 // indicates that the given flag should be included, but flags finding should NOT descend into sub-flags
	SkipAndDescend    FilterResult = 0b10 // indicates that the given flag should be skipped, but flags finding should descend into sub-flags
	SkipNoDescend     FilterResult = 0b11 // indicates that the given flag should be skipped and flags finding should NOT descend into sub-flags
	noDescendMask     FilterResult = 0b01
	skipMask          FilterResult = 0b10
)

// Filter applies all filter function to the provided flag and returns filtering decision.
func Filter(f Flag, filters ...FilterFunc) (r FilterResult) {
	if f == nil {
		return SkipNoDescend
	}
	for _, cond := range filters {
		r |= cond(f)
	}
	return r
}

// Recursive returns set of flags for the provided value and all values within, recursively, according to the provided filters. Function silently skips all the values that cannot be used as flag values.
func Recursive(def any, filters ...FilterFunc) []Flag {
	if def == nil {
		return nil
	}
	base := reflect.ValueOf(def)
	if !base.CanSet() && (base.Kind() != reflect.Pointer || base.IsNil()) {
		return nil
	}
	return recursive(base, nil, nil, filters)
}

func recursive(base reflect.Value, fieldsIndexes []int, fields []reflect.StructField, filters []FilterFunc) []Flag {
	flags := []Flag(nil)
	flag := newFlag(base, slices.Clone(fieldsIndexes), slices.Clone(fields))
	filterResult := Filter(flag, filters...)
	if filterResult&skipMask == 0 {
		flags = append(flags, flag)
	}
	if filterResult&noDescendMask != 0 {
		return flags
	}

	t := base.Type()
	if len(fields) > 0 {
		t = fields[len(fields)-1].Type
	}
	if t.Kind() == reflect.Pointer {
		t = t.Elem()
	}
	if t.Kind() != reflect.Struct {
		return flags
	}
	for i := range t.NumField() {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}
		flags = append(flags, recursive(base, append(fieldsIndexes, i), append(fields, field), filters)...)
	}
	return flags
}

func newFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) Flag {
	t := defaultBase.Type()
	if len(fields) > 0 {
		t = fields[len(fields)-1].Type
	}
	if t.Kind() == reflect.Pointer {
		t = t.Elem()
	}
	switch t.Kind() {
	case reflect.Bool:
		return newBoolFlag(defaultBase, fieldsIndexes, fields)
	case reflect.Int:
		return newIntFlag(0, defaultBase, fieldsIndexes, fields)
	case reflect.Int8:
		return newIntFlag(8, defaultBase, fieldsIndexes, fields)
	case reflect.Int16:
		return newIntFlag(16, defaultBase, fieldsIndexes, fields)
	case reflect.Int32:
		return newIntFlag(32, defaultBase, fieldsIndexes, fields)
	case reflect.Int64:
		return newIntFlag(64, defaultBase, fieldsIndexes, fields)
	case reflect.Uint:
		return newUintFlag(0, defaultBase, fieldsIndexes, fields)
	case reflect.Uint8:
		return newUintFlag(8, defaultBase, fieldsIndexes, fields)
	case reflect.Uint16:
		return newUintFlag(16, defaultBase, fieldsIndexes, fields)
	case reflect.Uint32:
		return newUintFlag(32, defaultBase, fieldsIndexes, fields)
	case reflect.Uint64:
		return newUintFlag(64, defaultBase, fieldsIndexes, fields)
	case reflect.Float32:
		return newFloatFlag(32, defaultBase, fieldsIndexes, fields)
	case reflect.Float64:
		return newFloatFlag(64, defaultBase, fieldsIndexes, fields)
	case reflect.Complex64:
		return newComplexFlag(64, defaultBase, fieldsIndexes, fields)
	case reflect.Complex128:
		return newComplexFlag(128, defaultBase, fieldsIndexes, fields)
	case reflect.String:
		return newStringFlag(defaultBase, fieldsIndexes, fields)
	case reflect.Slice:
		return newSliceFlag(t, defaultBase, fieldsIndexes, fields)
	case reflect.Map:
		return newMapFlag(defaultBase, fieldsIndexes, fields)
	case reflect.Struct:
		return newStructFlag(defaultBase, fieldsIndexes, fields)
	}
	return nil
}

func newSliceFlag(typ reflect.Type, defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) Flag {
	t := typ.Elem()
	if t.Kind() == reflect.Pointer {
		t = t.Elem()
	}
	switch t.Kind() {
	case reflect.Bool:
		return newBoolSliceFlag(defaultBase, fieldsIndexes, fields)
	case reflect.Int:
		return newIntSliceFlag(0, defaultBase, fieldsIndexes, fields)
	case reflect.Int8:
		return newIntSliceFlag(8, defaultBase, fieldsIndexes, fields)
	case reflect.Int16:
		return newIntSliceFlag(16, defaultBase, fieldsIndexes, fields)
	case reflect.Int32:
		return newIntSliceFlag(32, defaultBase, fieldsIndexes, fields)
	case reflect.Int64:
		return newIntSliceFlag(64, defaultBase, fieldsIndexes, fields)
	case reflect.Uint:
		return newUintSliceFlag(0, defaultBase, fieldsIndexes, fields)
	case reflect.Uint8:
		return newUintSliceFlag(8, defaultBase, fieldsIndexes, fields)
	case reflect.Uint16:
		return newUintSliceFlag(16, defaultBase, fieldsIndexes, fields)
	case reflect.Uint32:
		return newUintSliceFlag(32, defaultBase, fieldsIndexes, fields)
	case reflect.Uint64:
		return newUintSliceFlag(64, defaultBase, fieldsIndexes, fields)
	case reflect.Float32:
		return newFloatSliceFlag(32, defaultBase, fieldsIndexes, fields)
	case reflect.Float64:
		return newFloatSliceFlag(64, defaultBase, fieldsIndexes, fields)
	case reflect.Complex64:
		return newComplexSliceFlag(64, defaultBase, fieldsIndexes, fields)
	case reflect.Complex128:
		return newComplexSliceFlag(128, defaultBase, fieldsIndexes, fields)
	case reflect.String:
		return newStringSliceFlag(defaultBase, fieldsIndexes, fields)
	case reflect.Slice:
		return newSliceSliceFlag(defaultBase, fieldsIndexes, fields)
	case reflect.Map:
		return newMapSliceFlag(defaultBase, fieldsIndexes, fields)
	case reflect.Struct:
		return newStructSliceFlag(defaultBase, fieldsIndexes, fields)
	}
	return nil
}

type structField struct {
	defaultBase   reflect.Value
	fieldsIndexes []int
	fields        []reflect.StructField
}

func fieldByIndex(v reflect.Value, index []int) reflect.Value {
	if len(index) == 0 {
		if v.Kind() == reflect.Pointer && v.IsNil() {
			v.Set(reflect.New(v.Type().Elem()))
		}
		return v
	}
	if !((v.Kind() == reflect.Pointer && v.Type().Elem().Kind() == reflect.Struct) || v.Kind() == reflect.Struct) {
		panic(fmt.Sprintf("jsonflag: expected a struct or a pointer to struct, got %s", v.Kind().String()))
	}
	for _, x := range index {
		if v.Kind() == reflect.Pointer {
			if v.IsNil() {
				v.Set(reflect.New(v.Type().Elem()))
			}
			v = v.Elem()
		}
		v = v.Field(x)
	}
	if v.Kind() == reflect.Pointer && v.IsNil() {
		v.Set(reflect.New(v.Type().Elem()))
	}
	return v
}

func typesMustMatch(x, y reflect.Type) {
	if x != y {
		panic(fmt.Sprintf("types mismatch %s != %s", x.String(), y.String()))
	}
}

func elemIfPtr(v reflect.Value) reflect.Value {
	if v.Kind() != reflect.Pointer {
		return v
	}
	if v.IsNil() {
		return reflect.Zero(v.Type().Elem())
	}
	return v.Elem()
}

func elemIfPtrType(t reflect.Type) reflect.Type {
	if t.Kind() != reflect.Pointer {
		return t
	}
	return t.Elem()
}

func valueSet(dst, src reflect.Value) {
	if dst.Kind() == reflect.Pointer && !dst.CanSet() {
		dst = dst.Elem()
	}
	if dst.Kind() == reflect.Pointer && src.Kind() != reflect.Pointer {
		src = src.Addr()
	} else if dst.Kind() != reflect.Pointer && src.Kind() == reflect.Pointer {
		src = src.Elem()
	}
	dst.Set(src)
}

func valueAppend(slc, v reflect.Value) reflect.Value {
	if slc.Elem().Kind() == reflect.Pointer && v.Kind() != reflect.Pointer {
		v = v.Addr()
	} else if slc.Elem().Kind() != reflect.Pointer && v.Kind() == reflect.Pointer {
		v = v.Elem()
	}
	return reflect.Append(slc, v)
}

func (f *structField) init(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) {
	f.defaultBase = defaultBase
	f.fieldsIndexes = fieldsIndexes
	f.fields = fields
}

func (f *structField) Path() []reflect.StructField {
	return f.fields
}

func (f *structField) Type() reflect.Type {
	if len(f.fields) == 0 {
		return f.defaultBase.Type()
	}
	return f.fields[len(f.fields)-1].Type
}

func (f *structField) Default() reflect.Value {
	return fieldByIndex(f.defaultBase, f.fieldsIndexes)
}

type boolFlag struct {
	structField
}

func newBoolFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *boolFlag {
	f := &boolFlag{}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *boolFlag) Default() string {
	v := elemIfPtr(f.structField.Default()).Bool()
	if !v {
		return ""
	}
	return strconv.FormatBool(v)
}

func (f *boolFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseBool(val)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		fieldByIndex(b, f.fieldsIndexes).Set(reflect.ValueOf(v))
		return nil
	})
	return ops, nil
}

type intFlag struct {
	structField
	bitSize int
}

func newIntFlag(bitSize int, defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *intFlag {
	f := &intFlag{bitSize: bitSize}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *intFlag) Default() string {
	v := elemIfPtr(f.structField.Default()).Int()
	if v == 0 {
		return ""
	}
	return strconv.FormatInt(v, 10)
}

func (f *intFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseInt(val, 0, f.bitSize)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		fieldByIndex(b, f.fieldsIndexes).Set(reflect.ValueOf(v))
		return nil
	})
	return ops, nil
}

type uintFlag struct {
	structField
	bitSize int
}

func newUintFlag(bitSize int, defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *uintFlag {
	f := &uintFlag{bitSize: bitSize}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *uintFlag) Default() string {
	v := elemIfPtr(f.structField.Default()).Uint()
	if v == 0 {
		return ""
	}
	return strconv.FormatUint(v, 10)
}

func (f *uintFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseUint(val, 0, f.bitSize)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		fieldByIndex(b, f.fieldsIndexes).Set(reflect.ValueOf(v))
		return nil
	})
	return ops, nil
}

type floatFlag struct {
	structField
	bitSize int
}

func newFloatFlag(bitSize int, defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *floatFlag {
	f := &floatFlag{bitSize: bitSize}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *floatFlag) Default() string {
	v := elemIfPtr(f.structField.Default()).Float()
	if v == 0 {
		return ""
	}
	return strconv.FormatFloat(v, 'g', -1, f.bitSize)
}

func (f *floatFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseFloat(val, f.bitSize)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		fieldByIndex(b, f.fieldsIndexes).Set(reflect.ValueOf(v))
		return nil
	})
	return ops, nil
}

type complexFlag struct {
	structField
	bitSize int
}

func newComplexFlag(bitSize int, defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *complexFlag {
	f := &complexFlag{bitSize: bitSize}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *complexFlag) Default() string {
	v := elemIfPtr(f.structField.Default()).Complex()
	if v == 0 {
		return ""
	}
	return strconv.FormatComplex(v, 'g', -1, f.bitSize)
}

func (f *complexFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseComplex(val, f.bitSize)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		fieldByIndex(b, f.fieldsIndexes).Set(reflect.ValueOf(v))
		return nil
	})
	return ops, nil
}

type stringFlag struct {
	structField
}

func newStringFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *stringFlag {
	f := &stringFlag{}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *stringFlag) Default() string {
	return elemIfPtr(f.structField.Default()).String()
}

func (f *stringFlag) Apply(ops Operations, val string) (Operations, error) {
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		fieldByIndex(b, f.fieldsIndexes).Set(reflect.ValueOf(val))
		return nil
	})
	return ops, nil
}

type mapFlag struct {
	structField
}

func newMapFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *mapFlag {
	f := &mapFlag{}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *mapFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *mapFlag) Apply(ops Operations, val string) (Operations, error) {
	t := elemIfPtrType(f.structField.Type())
	v := reflect.MakeMap(t).Addr()
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		valueSet(fieldByIndex(b, f.fieldsIndexes), v)
		return nil
	})
	return ops, nil
}

type structFlag struct {
	structField
}

func newStructFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *structFlag {
	f := &structFlag{}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *structFlag) Default() string {
	b, err := json.Marshal(f.structField.Default().Interface())
	if err != nil {
		return ""
	}
	str := string(b)
	if str == "{}" {
		return ""
	}
	return str
}

func (f *structFlag) Apply(ops Operations, val string) (Operations, error) {
	t := elemIfPtrType(f.structField.Type())
	v := reflect.New(t)
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		valueSet(fieldByIndex(b, f.fieldsIndexes), v)
		return nil
	})
	return ops, nil
}

type boolSliceFlag struct {
	structField
}

func newBoolSliceFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *boolSliceFlag {
	f := &boolSliceFlag{}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *boolSliceFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *boolSliceFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseBool(val)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		x := fieldByIndex(b, f.fieldsIndexes)
		valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
		return nil
	})
	return ops, nil
}

type intSliceFlag struct {
	structField
	bitSize int
}

func newIntSliceFlag(bitSize int, defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *intSliceFlag {
	f := &intSliceFlag{bitSize: bitSize}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *intSliceFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *intSliceFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseInt(val, 0, f.bitSize)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		x := fieldByIndex(b, f.fieldsIndexes)
		valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
		return nil
	})
	return ops, nil
}

type uintSliceFlag struct {
	structField
	bitSize int
}

func newUintSliceFlag(bitSize int, defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *uintSliceFlag {
	f := &uintSliceFlag{bitSize: bitSize}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *uintSliceFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *uintSliceFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseUint(val, 0, f.bitSize)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		x := fieldByIndex(b, f.fieldsIndexes)
		valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
		return nil
	})
	return ops, nil
}

type floatSliceFlag struct {
	structField
	bitSize int
}

func newFloatSliceFlag(bitSize int, defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *floatSliceFlag {
	f := &floatSliceFlag{bitSize: bitSize}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *floatSliceFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *floatSliceFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseFloat(val, f.bitSize)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		x := fieldByIndex(b, f.fieldsIndexes)
		valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
		return nil
	})
	return ops, nil
}

type complexSliceFlag struct {
	structField
	bitSize int
}

func newComplexSliceFlag(bitSize int, defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *complexSliceFlag {
	f := &complexSliceFlag{bitSize: bitSize}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *complexSliceFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	li := make([]string, 0, v.Len())
	for _, x := range v.Seq2() {
		li = append(li, `"`+strconv.FormatComplex(elemIfPtr(x).Complex(), 'g', -1, f.bitSize)+`"`)
	}
	return "[" + strings.Join(li, ",") + "]"
}

func (f *complexSliceFlag) Apply(ops Operations, val string) (Operations, error) {
	v, err := strconv.ParseComplex(val, f.bitSize)
	if err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		x := fieldByIndex(b, f.fieldsIndexes)
		valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(v)))
		return nil
	})
	return ops, nil
}

type stringSliceFlag struct {
	structField
}

func newStringSliceFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *stringSliceFlag {
	f := &stringSliceFlag{}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *stringSliceFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *stringSliceFlag) Apply(ops Operations, val string) (Operations, error) {
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		x := fieldByIndex(b, f.fieldsIndexes)
		valueSet(x, valueAppend(elemIfPtr(x), reflect.ValueOf(val)))
		return nil
	})
	return ops, nil
}

type sliceSliceFlag struct {
	structField
}

func newSliceSliceFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *sliceSliceFlag {
	f := &sliceSliceFlag{}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *sliceSliceFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *sliceSliceFlag) Apply(ops Operations, val string) (Operations, error) {
	sliceType := elemIfPtrType(f.structField.Type())
	t := elemIfPtrType(sliceType.Elem()) // slice element type
	v := reflect.MakeSlice(t, 0, 0).Addr()
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		x := fieldByIndex(b, f.fieldsIndexes)
		valueSet(x, valueAppend(elemIfPtr(x), v))
		return nil
	})
	return ops, nil
}

type mapSliceFlag struct {
	structField
}

func newMapSliceFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *mapSliceFlag {
	f := &mapSliceFlag{}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *mapSliceFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *mapSliceFlag) Apply(ops Operations, val string) (Operations, error) {
	sliceType := elemIfPtrType(f.structField.Type())
	t := elemIfPtrType(sliceType.Elem()) // slice element type
	v := reflect.MakeMap(t).Addr()
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		x := fieldByIndex(b, f.fieldsIndexes)
		valueSet(x, valueAppend(elemIfPtr(x), v))
		return nil
	})
	return ops, nil
}

type structSliceFlag struct {
	structField
}

func newStructSliceFlag(defaultBase reflect.Value, fieldsIndexes []int, fields []reflect.StructField) *structSliceFlag {
	f := &structSliceFlag{}
	f.init(defaultBase, fieldsIndexes, fields)
	return f
}

func (f *structSliceFlag) Default() string {
	v := elemIfPtr(f.structField.Default())
	if v.Len() == 0 {
		return ""
	}
	b, err := json.Marshal(v.Interface())
	if err != nil {
		return ""
	}
	return string(b)
}

func (f *structSliceFlag) Apply(ops Operations, val string) (Operations, error) {
	sliceType := elemIfPtrType(f.structField.Type())
	t := elemIfPtrType(sliceType.Elem()) // slice element type
	v := reflect.New(t)
	if err := json.Unmarshal([]byte(val), v.Interface()); err != nil {
		return ops, err
	}
	ops = append(ops, func(base any) error {
		b := reflect.ValueOf(base)
		typesMustMatch(f.defaultBase.Type(), b.Type())
		x := fieldByIndex(b, f.fieldsIndexes)
		valueSet(x, valueAppend(elemIfPtr(x), v))
		return nil
	})
	return ops, nil
}
